# 进程和线程

## 进程和线程

### 1. 概念

进程是对运行时程序的封装，是**系统进行资源调度和分配的的基本单位，实现了操作系统的并发**；

线程是进程的子任务，**是CPU调度和分派的基本单位**，**用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位**。每个线程都独自占用一个**虚拟处理器**：独自的**寄存器组**，**指令计数器和处理器状态**。每个线程完成不同的任务，但是**共享同一地址空间**（也就是同样的**动态内存，映射文件，目标代码等等**），**打开的文件队列和其他内核资源**。

### 2. 区别：

1.  **一个线程只能属于一个进程，而一个进程可以有多个线程**，但至少有一个线程。线程依赖于进程而存在。 
2.  **进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存**。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
3.  **进程是资源分配的最小单位，线程是CPU调度的最小单位**； 
4.  系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，**进程切换的开销也远大于线程切换的开销**。 
5.  通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。**进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性**。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 
6.  **进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂**。 
7.  **进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉** 
8.  **进程适应于多核、多机分布；线程适用于多核**

## 进程间通信的方式：

进程间通信主要包括**管道、系统IPC（包括**[**消息队列**](https://cloud.tencent.com/product/cmq?from=10680)**、信号量、信号、共享内存等）、以及套接字socket**。

### 1.管道：

管道主要包括**匿名管道和命名管道**:管道可用于具有亲缘关系的父子进程间的通信，命名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信

- 1.1 **匿名管道PIPE**：

1. 它是**半双工**的（即数据只能在一个方向上流动），具有固定的读端和写端
2. 它**只能用于具有亲缘关系的进程之间的通信**（也是父子进程或者兄弟进程之间）
3. 它可以看成是一种特殊的文件，**对于它的读写也可以使用普通的read、write等函数**。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

- 1.2 命名管道FIFO：

1. FIFO**可以在无关的进程之间交换数据**
2. FIFO有路径名与之相关联，它**以一种特殊设备文件形式存在于文件系统中**。

### 2. 系统IPC：

- ##### 2.1 消息队列 消息队列，**是消息的链接表，存放在内核中**。一个消息队列由一个标识符（即队列ID）来标记。 (**消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点**)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

  特点：

  1. 消息队列是**面向记录的**，其中的消息具有特定的格式以及特定的优先级。
  2. 消息队列**独立于发送与接收进程**。进程终止时，消息队列及其内容并不会被删除。
  3. 消息队列**可以实现消息的随机查询**,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

- ##### 2.2 信号量semaphore 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个**计数器，可以用来控制多个进程对共享资源的访问**。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

  特点：

  1. 信号量用于**进程间同步**，若要在进程间传递数据需要结合共享内存。
  2. 信号量**基于操作系统的 PV 操作**，程序对信号量的操作都是原子操作。
  3. **每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数**。
  4. **支持信号量组**。

- ##### 2.3 信号signal

  信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

- ##### 2.4 共享内存（Shared Memory）

  它使得**多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新**。这种方式需要依靠某种同步操作，如互斥锁和信号量等

  特点：

  1. 共享内存是最快的一种IPC，因为进程是直接对内存进行存取
  2. 因为多个进程可以同时操作，所以需要进行同步
  3. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

### 3.套接字SOCKET：

socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。

- 线程间通信的方式: 临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作进程间通信的方式： 进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。

## 参考

https://cloud.tencent.com/developer/article/1688297



# spa

https://cloud.tencent.com/developer/article/1135301

**spa**全称：single-page application（单页应用）

是一种特殊的Web应用。它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML,从而实现UI与用户的交互。

# 事件委托

事件委托也称之为事件代理（Event Delegation）。 是JavaScript中常用绑定事件的常用技巧。 顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。 事件代理的原理是DOM元素的事件冒泡。



# css伪类和伪元素及选择器优先级

https://www.jianshu.com/p/dfc749ba0eab

## 伪类

> 伪类是一种**虚构的状态**或者是一个**具有特殊属性的元素可以使用css进行样式修饰**。

常见的几种伪类有：

- `:link`：代表链接的正常状态，用于选择未访问的链接。

- `:visited`：用于已经被访问过的链接。

- `:hover`：伪类用于当用户的鼠标悬停在链接之上时对元素的样式修饰

- `:active`：鼠标点击时激活

- `:first-child`：第一个孩子

- `:nth-child`：第n个孩子

- `:nth-of-type`：

  例如：`p:nth-of-type（n）`表示父元素的第n个段落（p）

==在这里需要声明一点，`:link`伪元素需要在所有此类别的伪元素之前声明。其顺序为`:link`, `:visited`, `:hover`, `:active`。==

**父元素的第n个段落（p）**
伪元素，更像是虚拟的元素可以和HTML元素一样对待。区别在于它们并不存在于文档树或者DOM之中。这意味着我们并没有真正的指定伪元素，但是可以使用CSS进行创建。

## 伪元素

常见的几种伪元素

```ruby
:after,:before,:first-letter
```

在伪元素中，css3引入双冒号（`::`），但是为了更好地兼容浏览器，也可以使用单冒号（`:`）。但是有一些为元素必须使用双冒号，`::backdrop`。

伪元素通过CSS生成内容是通过`content`属性结合`:before`或者`:after`伪元素来实现。

### `::before`

`:before`伪元素和它的兄弟`:after`，用来给另外一个HTML元素添加内容(文本或者图形)。同样的，添加的内容并不在DOM中真实存在但是可操纵。另外，内容的属性需要在CSS中声明。

需要记住，使用这个伪元素添加的文本不可以被选择。

- HTML:

  ```html
  <h1>Ricardo</h1>
  ```

- CSS

  ```css
  h1:before {
      content: "Hello "; /* Note the space after the word Hello. */
  }
  ```

- 显示

  ```powershell
  Hello Ricardo!
  ```

- ==注意==

  ```javascript
  h1[0].innerText // Ricardo 
  h1[0].innerHtml 
  /* 
  <h1> 
  	::before
      Ricardo
  </h1>
  */
  ```

  

### `::after`

`:after`伪元素用来向另一个HTML元素中添加内容(同样的也是文本或者图形)。被添加的内容不存在于DOM中，但是可操纵。为了更好地工作，内容属性需要在CSS中声明。

注意，使用这个伪元素添加的内容不可以被选择。

- HTML:

  ```html
  <h1>Ricardo</h1>
  ```

- CSS

  ```css
  h1:after {
      content: ", Web Designer!";
  }
  ```

- 显示

  ```powershell
  Ricardo, Web Designer!
  ```

### `::BACKDROP (EXPERIMENTAL)`

`::backdrop`伪元素是一个盒子，在全屏元素之后生成，但是在其它所有内容之上。它经常和`:fullscreen`伪类结合使用改变最大化屏幕的背景颜色 - 如果你不想使用默认的黑色。

**注意:** `::backdrop`伪元素需要使用双冒号，使用单冒号不起作用。

让我们再次继续`:fullscreen`伪类的示例。

**HTML:**

```html
<h1 id="element">This heading will have a solid background color in full-screen mode.</h1>
<button onclick="var el = document.getElementById('element'); el.webkitRequestFullscreen();">Trigger full scre
```

### `::FIRST-LETTER/:FIRST-LETTER`

`:first-letter` 伪元素用来选择文本的第一个字母。

如果第一行文本包含一个元素，如图片，播放器或者表格，这时第一个字母不会被影响仍旧可以被选择。

这在段落中是一个很好的应用，如：在不需要使用图片或者外部设置时，可以提高段落的吸引力。

**提示:**使用`:before`伪元素生成的内容文本，即使不存在于DOM中，其文本的第一个字母可以被指定。==他能看到：before的东西==

### `::FIRST-LINE/:FIRST-LINE`

`:first-line`伪元素指定一个元素的第一行。它旨在块级元素中起作用，在行内元素不起作用。

当在段落中使用时，如:只是给段落的第一行文本改变样式，即使文本被包裹。

**CSS:**

```css
p:first-line {
    background: orange;
}
```

## 选择器优先级

首先来看一下css选择符(css选择器)有哪些?

1.标签选择器(如：body,div,p,ul,li)

2.类选择器(如：class="head",class="head_logo")

3.ID选择器(如：id="name",id="name_txt")

4.全局选择器(如：*号)

5.组合选择器(如：.head .head_logo,注意两选择器用空格键分开)

6.后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)

7.群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示

8.继承选择器(如：div p,注意两选择器用空格键分开)

9.伪类选择器(如：就是链接样式,a元素的伪类，4种不同的状态：link、visited、active、hover。)

10.字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)

11.子选择器 (如：div>p ,带大于号>)

12.CSS 相邻兄弟选择器器 (如：h1+p,带加号+)

### 优先级

**不同级别**
 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。
 作为style属性写在元素内的样式
 1、id选择器
 2、类选择器|伪类选择器（nth-child等）|属性选择器（[title]）
 3、 标签选择器
 4、 通配符选择器
 5、浏览器自定义或继承

!important > 行内样式>ID选择器 > 类选择器=伪类=属性 > 标签 > 通配符 > 继承 > 浏览器默认属性

`!important`

```css
p {
  background-color: red !important;
}
```

















